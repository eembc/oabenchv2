#==============================================================================
#$RCSfile: makefile,v $
#
#   DESC : Application Level Make
#
# AUTHOR : Rick Foos, ECL, LLC
#
#  EEMBC : Technical Advisory Group (TechTAG)
#
#    CVS : $Revision: 1.83 $
#------------------------------------------------------------------------------
# Copyright (c) 1998-2005 by the EDN Embedded Microprocessor 
# Benchmark Consortium (EEMBC), Inc. All Rights Reserved.
#==============================================================================

# Default Test Harness used to build benchmarks.
LITE	= _lite

# Default Tool Chain used to build the benchmarks.
TOOLCHAIN=gcc

# Default Tool Chain to build HOST based components 
# NOTE: Host Tool Chain MUST be defined in utils/make/<HOSTCHAIN>.mak
HOSTCHAIN=gcc
HOSTEXE=.exe

# Optional: Extra Arguments Passed to compiler.
#COMPILER_DEFINES =

# Optional: Command line arguments passed to cheader.
#CMDLINE_CHEADER=
# Skip cheader scan after libraries are built (development only).
#CMDLINE_CHEADER=skip

# Build flag for Benchmark Version to allow unified V1.1 and V2.0 build tree.
VER=v2

# Reserved constants, do not quote file extensions, dependency never triggers
TLOGTYP=_time
SLOGTYP=_size
CLOGTYP=_count
PLOGTYP=_psnr
THLITE=_lite
# Cygwin ifeq requires unquoted
TH816=_816
PERL=`which perl || exit 1`
AWK=`which gawk || which awk || exit 1`

# ROOT directory for Harness and Utilities
ROOT		= ..

# Subcommittee name based on current working directory.
APPLICATION=`pwd | sed -e "s|.*\/||"`

# Utilities for Source Code Line Count (make count)
AWKSCLC=sclc
SCLC=$(ROOT)/util/perl/sclc -ignore -recurse 

# Root Directory for EEMBC test harness source code
TH			= $(ROOT)/th$(LITE)

# By Default, a seperate al directory per platform.
# If you want each toolchain to reference the same AL, define
# PLATFORM=TOOLCHAIN, in <TOOLCHAIN>.mak, and create an AL
# directory with the appropriate files in $TH/$TOOLCHAIN/al
THPORT		= $(TH)/$(PLATFORM)

# Toolchain Directory, Allows override from command line.
TCDIR	= $(ROOT)/util/make

# Directories for Executables, Objects/Library, and Benchmark Results.
HOSTBUILD	= $(HOSTCHAIN)/bin$(LITE)
BINBUILD	= $(TOOLCHAIN)/bin$(LITE)
OBJBUILD	= $(TOOLCHAIN)/obj$(LITE)
RESULTS		= $(TOOLCHAIN)/results$(LITE)

# Directories to be included for the test harness
# SG: gs8 requires config files with same name as the original file, that reside in a different directory
#     must not include "." first in the chain, otherwise confusion.
THINCS		= $(CINCD)$(ROOT)/oav2 $(CINCD)$(THPORT)/al $(CINCD)$(TH)/src

# Library file generated by harness.mak
# old obj link possible, change THLIB to THOBJS in depgen.cml files, and
# remove diffmesure from build.
ifeq ($(LITE),$(TH816))
THLIB		= 
else
THLIB		= $(OBJBUILD)/thobjs$(LITE)$(LIBTYPE)
endif

# Set target dependency file based on build
# Set target dependency file for HOST build
ifeq ($(LITE),$(TH816))
TARGETFILE	= targets$(VER)_$(TARGETS)$(TH816).mak
HOSTFILE	= targets$(VER)_host$(TH816).mak
else
TARGETFILE	= targets$(VER)_$(TARGETS).mak
HOSTFILE	= targets$(VER)_host.mak
endif

# Additional dependencies for file system libraries
ARDEPS	= $(ROOT)/util/perl/makerule.mak
ARDEPS	+= $(TARGETFILE)

# Additional dependencies for each benchmark
BMDEPS	= harness.h $(THPORT)/al/eembc_dt.h $(THPORT)/al/thcfg.h \
		$(THPORT)/al/heapport.h 
# makefile
BMDEPS	+= $(TCDIR)/$(TOOLCHAIN).mak
BMDEPS	+= $(ROOT)/util/perl/makerule.mak
BMDEPS	+= iterations$(VER)$(PLATFORM).mak
BMDEPS	+= $(TARGETFILE)
ifneq ($(LITE),$(TH816))
BMDEPS	+= $(TH)/$(TARGETS)/harness.mak
endif

# Include Tool Chain Definition and Control file
# Tool Executables:
#	CC (compiler), AS(assembler), LD(linker), AR(librarian),SIZE(size utility)
# Tool Flags:
#	COMPILER_FLAGS, COMPILER_DEBUG, COMPILER_DEFINES, WARNING_OPTIONS, 
#	COMPILER_INCLUDES, LINK_FLAGS, LINK_INLCUDES, ASSEMBLER_FLAGS, 
#	LIBRARY_FLAGS
# Control Defines:
#	ALL_TARGETS, RUN, RUN_FLAGS
include	$(TCDIR)/$(TOOLCHAIN).mak

# Variables used by targets.mak

CINCS	= $(COMPILER_INCLUDES) $(THINCS)

# Compile for Debugger
CFLAGSD	= $(WARNING_OPTIONS) $(COMPILER_DEBUG) $(COMPILER_DEFINES) 
CCD		= $(CC) $(COBJT) $(CFLAGSD) $(CINCS) 

# Compile for Benchmarking
CFLAGS	= $(WARNING_OPTIONS) $(COMPILER_FLAGS) $(COMPILER_DEFINES)
CCC		= $(CC) $(COBJT) $(CFLAGS) $(CINCS)  

# Compile for No Optimization
CFLAGSN	= $(COMPILER_NOOPT) $(COMPILER_DEFINES)
CCN		= $(CC) $(COBJT) $(CFLAGSN) $(CINCS)  

# Select Compile for Benchmarking, or Compile for Debug
COM		= $(CCC)

# Assembler definitions
AFLAGS	= $(ASSEMBLER_FLAGS) $(ASSEMBLER_INCLUDES)
ASM		= $(AS) $(AFLAGS)

# Linker Definitions
LFLAGS	= $(LINKER_FLAGS) $(LINKER_INCLUDES) 
LINK	= $(LD) $(LFLAGS)

# Librarian Definitions
ARFLAGS	= $(LIBRARY_FLAGS)
LIBRARY	= $(AR) $(ARFLAGS)

# Command Line used by run.mak for benchmarks
CMDLINE				+=-autogo
CMDLINE$(THLITE)	+=

# Compiler check. Upper level makefile may pass a non-working toolchain.
all:: compiler-check
# -x will not detect with '' strings needed to handle "" CC strings
# if -x sees empty string, it will have an error
# -z will detect empty with ''
.PHONY:compiler-check
compiler-check: 
	@if [ -z '$(CC)' ]; then \
	echo "*** TOOLCHAIN $(TOOLCHAIN) CC not defined, no compiles will be done."; \
	elif [ ! -x $(CC) ]; then \
	echo "*** TOOLCHAIN $(TOOLCHAIN) CC $(CC) is not executable"; \
	exit 1; \
	fi;\
	[ -d "${TOOLCHAIN}" ] || mkdir ${TOOLCHAIN}

# The following "all" target works where there is a run and a results utility
# (Not all platforms support run and results.)
# ALL_TARGETS defined in TOOLCHAIN
#ALL_TARGETS = mkdir targets run results
all:: cheader hosttargets $(ALL_TARGETS) 

#for oamark only, need to create dirs, then compile harness, then compile the benchmarks
targets-oamark2 :: mkdir

targets-oamark2 :: $(OBJBUILD)/thobjs$(LITE)$(LIBTYPE) 

targets-oamark2 :: \
	$(BINBUILD)/empty$(LITE)$(EXE) \
	$(BINBUILD)/bezierv2fixed$(LITE)$(EXE) \
	$(BINBUILD)/bezierv2float$(LITE)$(EXE) \
	$(BINBUILD)/textv2$(LITE)$(EXE) \
	$(BINBUILD)/ditherv2$(LITE)$(EXE) \
	$(BINBUILD)/rotatev2$(LITE)$(EXE) 

# Run with ONLY target executables (partial dependency chain)
# NOTE: Will produce errors if any required executables do not exist.
targetrun: cleanlogs
	@make BINBUILD=${BINBUILD} RESULTS=${RESULTS} THLIB= \
		RUN=$(RUN) RUN_FLAGS=$(RUN_FLAGS) \
		SIZE=$(SIZE) SIZE_FLAGS=$(SIZE_FLAGS) \
		CMDLINE="${CMDLINE}" LITE=${LITE} EXE=${EXE} CMDLINE_CHEADER=skip \
		-f run${VER}${PLATFORM}.mak runtarget;\
	make TOOLCHAIN=${TOOLCHAIN} HOSTCHAIN=${HOSTCHAIN} \
		TLOGTYP=${TLOGTYP} SLOGTYP=${SLOGTYP} PLOGTYP=${PLOGTYP} \
		VER=${VER} LITE=${LITE} AWK=${AWK} ROOT=${ROOT} EXE=${EXE} \
		RESULTS=${RESULTS} bmarks="${bmarks}" CMDLINE="${CMDLINE}" \
		AWKDIR=${AWKDIR} AWKSZ=${AWKSZ} CMDLINE_CHEADER=skip \
		-f results${VER}${PLATFORM}.mak


rerun: cleanlogs results

scrub: rmdir

# Remove all generated files.
distclean: cleanrule cleanlogs
	@echo "... Removing build dependencies from $(TOOLCHAIN)";\
	rm -rf $(TOOLCHAIN);\
	rm -f  $(TOOLCHAIN)$(TLOGTYP).log;\
	rm -f  $(TOOLCHAIN)$(TLOGTYP)$(THLITE).log;\
	rm -f  $(TOOLCHAIN)$(SLOGTYP).log;\
	rm -f  $(TOOLCHAIN)$(SLOGTYP)$(THLITE).log;\
	rm -f  $(TOOLCHAIN)$(PLOGTYP).log;\
	rm -f  $(TOOLCHAIN)$(PLOGTYP)$(THLITE).log;\
	rm -f  $(TOOLCHAIN)$(PLATFORM).log;\
	rm -f  $(TOOLCHAIN)$(PLATFORM)$(THLITE).log;\
	rm -rf `find . -name Debug`;\
	rm -rf `find . -name Release`;\
	rm -rf `find . -name Debug_lite`;\
	rm -rf `find . -name Release_lite`;\
	rm -f gmon.out


targets:: mkdir
run:: targets
results:: run

ifeq (${HOSTCHAIN},${TOOLCHAIN})
hosttargets:: mkdir
else
hosttargets::
	make TOOLCHAIN=${HOSTCHAIN} mkdir hosttargets
endif

# Following includes makerule.pl dependancies.
# (if not editing depgen.cml files, this may be commented out. The 
# targets<toolchain>.mak files will not be overwritten)
# You may also use the $TARGETS varaible to re-use the dependency files 
# from another toolchain. You can set this in util/make/<toolchain>.mak

include	$(ROOT)/util/perl/makerule.mak


# Following includes Test Harness Dependancies
# By Default, a dependency file per TOOLCHAIN. (TARGETS=TOOLCHAIN)
#
# If you want multiple toolchains to reference the same TH dependencies,
# set TARGETS=PLATFORM defined in <TOOLCHAIN>.mak.
# 
ifneq ($(LITE),$(TH816))
ifneq ($(MAKECMDGOALS),clean)
ifneq ($(MAKECMDGOALS),cleanrule)
ifneq ($(MAKECMDGOALS),distclean)
ifneq ($(MAKECMDGOALS),cleanlogs)
ifneq ($(MAKECMDGOALS),targetrun)
include	$(TH)/$(TARGETS)/harness.mak
endif
endif
endif
endif
endif
endif

# Following includes Compiler overrides for Benchmark iterations per platform.
include	iterations$(VER)$(PLATFORM).mak

# Include benchmark target dependencies generated by makerule.pl
ifneq ($(MAKECMDGOALS),clean)
ifneq ($(MAKECMDGOALS),cleanrule)
ifneq ($(MAKECMDGOALS),distclean)
ifneq ($(MAKECMDGOALS),cleanlogs)
ifneq ($(MAKECMDGOALS),targetrun)
include	$(TARGETFILE)
endif
endif
endif
endif
endif

# The following includes HOST utilities (if any).
# This is ONLY included for the defined HOST Toolchain (HOSTCHAIN).
ifeq (${HOSTCHAIN},${TOOLCHAIN})
ifneq ($(MAKECMDGOALS),clean)
ifneq ($(MAKECMDGOALS),cleanrule)
ifneq ($(MAKECMDGOALS),distclean)
ifneq ($(MAKECMDGOALS),cleanlogs)
ifneq ($(MAKECMDGOALS),targetrun)
include	${HOSTFILE}
endif
endif
endif
endif
endif
endif

# Make the directory structure for this suite and test harness
# Any platform/toolchain specific modifications can be edited in.
# NOTE: dirs uses TOOLCHAIN as root directory to seperate object files. This
# handles multiple Tool Chains from a single file.
include	dirs$(VER)$(PLATFORM).mak

# If it is possible to execute the benchmarks from make command it will
# be platform specific, so include the platform specific run commands.
# PLATFORM is defined in the TOOLCHAIN file.
include	run$(VER)$(PLATFORM).mak

# If it is possible to extract results from make command it will
# be platform specific, so include the platform specific results commands.
include	results$(VER)$(PLATFORM).mak

# Some shells require that variables are defined but NULL for loops.
bmarks?=""
bmextradirs?=""
bmarksrc?=""
rsextradirs?=""

# Compiler flags are reported for Certification, Generate information
# about the run into a log file. These are available in the make
# environment, so generate them here.
all:: $(TOOLCHAIN)$(PLATFORM)$(LITE).log

clean:: cleanobjs cleanprof 
	@echo "... Removing build dependencies from ${OBJBUILD}, ${BINBUILD}"

.PHONY: cleanprof
cleanprof:	
	@echo "... Removing profile info"
	@for i in $(bmarks) $(bmextradirs); do \
	rm -f $(OBJBUILD)/$$i/*.gcda $(OBJBUILD)/$$i/*.gcno $(OBJBUILD)/$$i/*.gprof; \
	done
	@rm -f $(OBJBUILD)/*.gcda $(OBJBUILD)/*.gcno 

.PHONY: cleanobjs
cleanobjs: cleanlogs
	@echo "... Removing bmark objects ";\
	rm -f $(OBJBUILD)/*$(OBJ); \
	rm -f $(OBJBUILD)/*$(LIBTYPE)
	@for i in $(bmarks) $(bmextradirs); do \
	rm -f $(OBJBUILD)/$$i/*$(OBJ); \
	rm -f $(OBJBUILD)/$$i/*$(LIBTYPE); \
	rm -f $(BINBUILD)/$$i$(LITE)$(EXE); \
	done

cleancheader clean:: cleanlogs
	@if [ -f "./cheader$(VER).sh" ]; then \
	echo "... Removing build dependencies from cheader$(VER).sh";\
	./cheader$(VER).sh ${CMDLINE_CHEADER} clean;\
	fi

# @note Added chmod check for gprof.sh here for convenience. DO_PROFILE=yes
	
.PHONY:cheader
cheader:
	@if [ -f "./cheader$(VER).sh" ]; then \
	[ ! -x "${ROOT}/util/bin/cheader.exe" ] && (make cleancheader);\
	(cd ${ROOT}/util && make);\
	[ ! -x "${ROOT}/util/bin/cheader.exe" ] && (echo "ERROR: ../util/bin/cheader.exe failed to build." && exit 1);\
	[ ! -x "./cheader$(VER).sh" ] && chmod +x "./cheader$(VER).sh";\
	[ ! -x "${ROOT}/util/shell/cinit.sh" ] && chmod +x "${ROOT}/util/shell/cinit.sh";\
	[ ! -x "${ROOT}/util/make/gprof.sh" ] && chmod +x "${ROOT}/util/make/gprof.sh";\
	./cheader$(VER).sh ${CMDLINE_CHEADER} ;\
	(make CMDLINE_CHEADER=skip depgen$(VER)_$(TARGETS).cml);\
	fi

OPTLOG=$(TOOLCHAIN)$(PLATFORM)$(LITE).log

$(TOOLCHAIN)$(PLATFORM)$(LITE).log : makefile $(TCDIR)/$(TOOLCHAIN).mak
	@echo -n "Logging ${TOOLCHAIN} compiler options for ${PLATFORM}, Harness TH${LITE}...";\
	pwd	>${OPTLOG} ;\
	echo "MAKE ENVIRONMENT FOR $(TOOLCHAIN)$(PLATFORM)"	>>${OPTLOG} ;\
	echo	>>${OPTLOG} ;\
	echo "TOOLCHAIN:	$(TOOLCHAIN)"	>>${OPTLOG} ;\
	echo "PLATFORM:	$(PLATFORM)"	>>${OPTLOG} ;\
	echo "TARGETS:	$(TARGETS)"	>>${OPTLOG} ;\
	echo "ALL TARGETS:	$(ALL_TARGETS)" >>${OPTLOG} ;\
	echo	>>${OPTLOG} ;\
	echo "COMPILER FLAGS:	$(CFLAGS)"	>>${OPTLOG} ;\
	echo	>>${OPTLOG} ;\
	echo "ASSEMBLER FLAGS:	$(AFLAGS)"	>>${OPTLOG} ;\
	echo "LIBRARY FLAGS:	$(ARFLAGS)"	>>${OPTLOG} ;\
	echo "LINKER FLAGS:	$(LFLAGS)"	>>${OPTLOG} ;\
	echo "RUN COMMAND:	$(RUN)"	>>${OPTLOG} ;\
	echo "RUN FLAGS:	$(RUN_FLAGS)"	>>${OPTLOG} ;\
	echo "COMMAND LINE:	$(CMDLINE$(LITE))"	>>${OPTLOG} ;\
	echo	>>${OPTLOG} ;\
	echo "${OPTLOG}."

#
# Count Section, COUNTLOGS defined in dirs.mak
#
APPLOG=${APPLICATION}$(CLOGTYP)$(VER).log

cleanlogs::
	@echo "... Removing build dependencies from $(TOOLCHAIN)<logtype>$(LITE)$(VER).log";\
	rm -f *.log;\
	for i in $(bmarks); do \
	rm -f $(RESULTS)/$$i*.log; \
	rm -f $(RESULTS)/$$i*.csv; \
	done
	@for i in $(rsextradirs); do \
	 rm -f $(TOOLCHAIN)/$$i/* ;\
	done

cleanlogs::
	@for i in ${COUNTLOGS} ${APPLOG}; do \
	rm -f $$i;\
	done

.PHONY:count
count: ${APPLICATION}$(CLOGTYP)$(VER).log

$(COUNTLOGS) :
	@echo "Counting source code lines...";\
	for i in $(bmarksrc); do \
	bm=`echo $$i | sed -e "s|\/|-|g"` ;\
	[ $$i = "empty" ] && continue;\
	echo "   $$i -> $$bm.count.log";\
	$(PERL) $(SCLC) $$i >$$bm.count.log ;\
	done;\
	echo "...done"

${APPLICATION}$(CLOGTYP)$(VER).log : $(COUNTLOGS)
	@rm -f ${APPLOG};\
	for i in $(bmarksrc); do \
	bm=`echo $$i | sed -e "s|\/|-|g"` ;\
	[ $$i = "empty" ] && continue;\
	$(AWK) -f $(ROOT)/util/$(AWKDIR)/count$(AWKSCLC).awk -v BMARK=$$bm $$bm.count.log >> ${APPLOG};\
	echo >> ${APPLOG};\
	done

.PHONY:mkdir	
mkdir:
	@[ -d "${BINBUILD}" ] || mkdir -p $(BINBUILD);\
	[  -d "${OBJBUILD}" ] || mkdir -p $(OBJBUILD);\
	[  -d "${RESULTS}"  ] || mkdir -p $(RESULTS);\
	for i in $(bmarks) $(bmextradirs); do \
	[ -d "${OBJBUILD}/$$i" ] || mkdir -p $(OBJBUILD)/$$i;\
	done;\
	for i in $(rsextradirs); do \
	[ -d "${TOOLCHAIN}/$$i" ] || mkdir -p $(TOOLCHAIN)/$$i;\
	done

.PHONY:rmdir
rmdir:
	@rm -rf $(BINBUILD) $(OBJBUILD) $(RESULTS)

.PHONY:dox
dox:
	@if [ -d dox ] && [ -f dox/Makefile ]; then \
		(cd dox;make);\
	fi

.PHONY: skip
skip:
	CMDLINE_CHEADER=skip

.PHONY: print-%
print-%:
	@echo $* = $($*)  
	@echo [Defined at $(origin $*)] 
